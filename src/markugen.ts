
import colors from 'colors';
import path from 'node:path';
import fs from 'node:fs';
import Generator from './generator';
import { version, name } from '../package.json';

/**
 * Theme options
 */
export interface Theme {
  color?:string,
  colorSecondary?:string,
  bgColor?:string,
  bgColorSecondary?:string,
  borderColor?:string,
  borderColorSecondary?:string,
  accentColor?:string,
  fontFamily?:string,
  fontFamilyHeaders?:string,
}

/**
 * Light and dark themes
 */
export interface Themes {
  light?:Theme,
  dark?:Theme,
}

/**
 * Markugen configuration options
 */
export interface Options {
  /**
   * The format of the {@link input} and {@link output}. If string is used for
   * the format, then the input is assumed to be a markdown string, else it
   * is assumed to be a file or directory. The string format option implies
   * {@link embed} and {@link inheritTitle} and will cause the 
   * {@link Generator.generate} function to
   * return the HTML as a string instead of writing a file.
   */
  format?:'file'|'string',
  /**
   * Location of the input directory to look for markdown files or a path to
   * a single markdown file.
   */
  input:string,
  /**
   * Location to output the html files [default: './output']. If {@link format}
   * is 'string' this should contain the name of the file that will be written
   * by the caller. If not provided, 'index.html' will be used.
   */
  output?:string,
  /**
   * The title to use for the navbar [default: 'Markugen vX.X.X']
   */
  title?:string,
  /**
   * If true, all pages not custom configured will inherit the site {@link title}.
   */
  inheritTitle?:boolean,
  /**
   * Overrides the footer html. [default: 'Generated by Markugen']
   */
  footer?:string,
  /**
   * Path to the home page of the site relative to the output directory.
   * The default will use the first ordered page at the root level.
   */
  home?:string,
  /**
   * If true, allows for raw html to be used in markdown
   */
  allowHtml?:boolean,
  /**
   * Maximum header depth to output in the Table of Contents. Values less than
   * or equal to zero will hide the Table of Contents. [default: 3]
   */
  toc?:number,
  /**
   * If true, all code (css and js) will be embedded in each file. The default
   * implementation will use a single file at the top-level.
   */
  embed?:boolean,
  /**
   * Relative path to an icon file to use as the favicon. The path must
   * be relative to the {@link input} directory. The file will automatically
   * be included as an {@link assets asset}.
   */
  favicon?:string,
  /**
   * Path(s) to assets folders or files to copy to output directory.
   * Directories will be copied recursively. By default, markugen will look
   * for a folder in the {@link input} directory called 'assets'. If you do
   * not want the default behavior, you must pass an empty array or string,
   * not undefined.
   */
  assets?:string|string[],
  /**
   * Additional JavaScript to embed in the script tag at the end of the body
   */
  script?:string,
  /**
   * Path or list of paths to js files to include. These files must be absolute
   * URLs or relative to the input directory.
   */
  js?:string|string[],
  /**
   * Additional CSS to embed in the style tag at the beginning of the document
   */
  style?:string,
  /**
   * Path or list of paths to css files to include. These files must be absolute
   * URLs or relative to the input directory.
   */
  css?:string|string[],
  /**
   * Defines the light and dark theme to use on the website. See {@link Theme}
   * for more details.
   */
  theme?:Themes,
  /**
   * If true, files and folders that begin with a dot (.) will be included.
   * By default, files and folders that begin with a dot (.) are ignored.
   */
  includeHidden?:boolean,
  /**
   * If true, the {@link output} directory will be cleared before generation
   */
  clearOutput?:boolean,
  /**
   * If true, markugen will silence its output.
   */
  quiet?:boolean,
  /**
   * Used internally to show full call stacks in an uncaught exception occurs.
   */
  debug?:boolean,
  /**
   * Allows for custom rewrites in the html nodes. This is documented in
   * the {@link https://github.com/jaywcjlove/rehype-rewrite} module. The
   * only additional parameter here is the path to the markdown 
   * file {@link mdfile}.
   */
  //rewrite?(node:Root|RootContent, mdfile:string, index?:number, parent?:Root|Element): void,
}

export interface OutputLabel {
  label: string,
  color?: colors.Color,
  ignoreQuiet?: boolean,
  error?: {
    exit: boolean,
    code?: number,
  },
}

export default class Markugen
{
  // stores the version of the app
  public readonly version:string = version;
  // stores the name of the app
  public readonly name:string = name;
  // stores the options
  public readonly options:Options;
  // stores the path to the package
  public readonly root:string;
  // the default light and dark theme
  public readonly defaultTheme:Themes = {
    light: {
      color: 'black',
      colorSecondary: 'black',
      bgColor: 'white',
      bgColorSecondary: '#e5e4e2',
      borderColor: '#c0c0c0',
      borderColorSecondary: 'black',
      accentColor: '#1f6feb',
      fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", STHeiti, "Microsoft YaHei", SimSun, sans-serif',
      fontFamilyHeaders: 'Georgia Pro, Crimson, Georgia, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", STHeiti, "Microsoft YaHei", SimSun, sans-serif',
    },
    dark: {
      color: 'white',
      colorSecondary: 'silver',
      bgColor: '#423f3e',
      bgColorSecondary: '#2b2b2b',
      borderColor: '#404040',
      borderColorSecondary: 'silver',
      accentColor: '#a371f7',
      fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", STHeiti, "Microsoft YaHei", SimSun, sans-serif',
      fontFamilyHeaders: 'Georgia Pro, Crimson, Georgia, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", STHeiti, "Microsoft YaHei", SimSun, sans-serif',
    }
  };

  /**
   * Constructs a new instance with the given options
   */
  public constructor(options:Options)
  {
    this.root = path.dirname(__dirname);
    this.options = options;

    // format should be done first
    this.options.format = options.format !== undefined ? options.format : 'file';
    // string format implies embed
    if (this.options.format === 'string')
    {
      this.options.embed = true;
      this.options.inheritTitle = true;
      this.options.output = options.output ? options.output : 'index.html';
    }
    // validate the input and options based on input
    else
    {
      this.options.input = path.resolve(options.input);
      if (!fs.existsSync(this.options.input))
      {
        this.error(`Input does not exist [${this.options.input}]`);
        return;
      }
      // add the assets if it exists in the input directory
      if (options.assets === undefined && fs.existsSync(path.resolve(this.inputDir, 'assets')))
        this.options.assets = ['assets'];
      // resolve output
      this.options.output = path.resolve(options.output ? options.output : './output');
    }

    this.options.includeHidden = options.includeHidden ? true : false;
    this.options.clearOutput = options.clearOutput ? true : false;
    this.options.title = options.title ? options.title : 'Markugen v' + this.version;
    this.options.toc = options.toc !== undefined ? options.toc : 3;
    this.setTheme();
    this.checkFavicon();
    this.checkCss();
    this.checkJs();
  }

  /**
   * Escapes all markdown special characters in the given value and returns
   * the new string.
   */
  public static escape(md:any):string
  {
    return md ? md.toString().replace(/([\\`*_{}[\]()#+\-.!:])/g, '\\$1') : '';
  }

  /**
   * Checks the validity of the js files
   */
  private checkJs()
  {
    if (this.options.js)
    {
      if (!Array.isArray(this.options.js)) this.options.js = [this.options.js];
      this.options.js = this.options.js.filter((file) => {
        if (!this.isRelative(file))
        {
          this.warning(`Given js file is not relative to input directory [${file}]`);
          return false;
        }
        return true;
      });
    }
  }
  /**
   * Checks the validity of the css files
   */
  private checkCss()
  {
    if (this.options.css)
    {
      if (!Array.isArray(this.options.css)) this.options.css = [this.options.css];
      this.options.css = this.options.css.filter((file) => {
        if (!this.isRelative(file))
        {
          this.warning(`Given css file is not relative to input directory [${file}]`);
          return false;
        }
        return true;
      });
    }
  }
  /**
   * Sets the appropriate themes based on the given values
   * @param themes the provided themes
   */
  private setTheme(themes?:Themes)
  {
    if (!themes) this.options.theme = this.defaultTheme;
    else 
    {
      this.options.theme = {
        light: themes.light ? {...this.defaultTheme.light, ...themes.light} : this.defaultTheme.light, 
        dark: themes.dark ? {...this.defaultTheme.dark, ...themes.dark} : this.defaultTheme.dark, 
      };
    }
  }
  /**
   * Checks the validity of the favicon
   */
  private checkFavicon()
  {
    if (this.options.favicon && !this.isRelative(this.options.favicon))
    {
      this.warning(`Given favicon is not relative to the input directory [${this.options.favicon}]`);
      this.options.favicon = undefined;
    }
  }
  /**
   * Returns true if the given file is relative to the input directory or is
   * a valid URL.
   * @param file the file to check
   * @returns true if the file is relative or a URL
   */
  public isRelative(file:string):boolean
  {
    // URLs are good to go 
    if (URL.canParse(file)) return true;
    // path cannot be absolute
    if (path.isAbsolute(file)) return false;
    // must be relative to the input directory
    return fs.existsSync(path.resolve(this.inputDir, file));
  }

  /**
   * Generates the documentation with the current options
   */
  public generate():string|undefined
  {
    return new Generator(this).generate();
  }

  /**
   * @returns true if the input given is a single file
   */
  public get isInputFile() { return fs.lstatSync(this.input).isFile(); }
  /**
   * @returns true if the input given is a string
   */
  public get isInputString() { return this.options.format === 'string'; }
  /**
   * @returns the path to the input
   */
  public get input() { return this.options.input; }
  /**
   * @returns the path to the input directory
   */
  public get inputDir()
  {
    return this.isInputFile ? path.dirname(this.input) : this.input;
  }
  /**
   * @returns the path to the output directory
   */
  public get output() { return this.options.output!; }
  /**
   * @returns true if hidden files and folders should be included
   */
  public get includeHidden() { return this.options.includeHidden; }
  
  /**
   * @returns true if the output should be cleared first
   */
  public get clearOutput() { return this.options.clearOutput; }

  /**
   * Starts a console group
   */
  public group(...args:any[]) { if(!this.options.quiet) console.group(...args); }
  /**
   * Ends a console group
   */
  public groupEnd() { if(!this.options.quiet) console.groupEnd(); }

  /**
   * Use in place of console.log so the app can handle coloring
   * and any cli options that were given
   */
  public log(label:OutputLabel|string, ...args:any[])
  {
    const ol = typeof label === 'string' ? {label: label} : label;
    if (!this.options.quiet && ol.ignoreQuiet !== true) 
    {
      const color = ol.color ? ol.color : (ol.error ? colors.red : colors.green);
      if (ol.error) ol.label ? console.error(color(ol.label), ...args) : console.error(...args);
      else ol.label ? console.log(color(ol.label), ...args) : console.log(...args);
      // check if we should exit
      if (ol.error && ol.error.exit === true)
        process.exit(ol.error.code);
    }
  }
  /**
   * Use in place of console.log so the app can handle coloring
   * and any cli options that were given
   */
  public warning(...args:any[])
  {
    this.log({ label: 'Warning:', color: colors.yellow }, ...args);
  }
  /**
   * Use in place of console.error so the app can handle coloring
   * and any cli options that were given. Also will exit with code 1.
   */
  public error(...args:any[])
  {
    this.log(
      { 
        label: 'Error:', 
        color: colors.red, 
        error: { exit: true, code: 1 },
      }, 
      ...args
    );
  }
}